# C# Functional Programming Fundimentals

This set of articles is about applying *Functional Programming* principles to C#

Functional programming is a programming paradigm that emphasizes the use of pure functions, immutability, and higher-order functions and objects.

Key features of Functional Programming

1. Functions are pure. 

1. Functions cab be Higher-Order.

1. Variables are Immutable.

1. Iteration uses Recursion. 

1. Referential Transparency.

## Containers

Containers are the fundimental building block of Functional Programming.  They don't have a universal name, so you can get petty confused between articles and even within the same article as author's use their own names and switch between names. *Wrapper*, *Kind*, *Higher Order Kind*,  *Higher Order Objects*, *Lifted Objects*, *Elevated Objects*,... to name but a few.

A container is a wrapper you can place around any object.  It's generic.  I've invented a term for them - *Containors*.  I'll use it from now on.

You are almost certainly using containers already.  `IEnumerable<T>` and `Task<T>` are good examples.

The purpose of a *containor* is to provide generic functionality regardless of the type.  Like `IEnumerable<T>` provides LINQ functionality to any object collection.

It can be expressed like this:

```csharp
Containor<T>
```

*FP* objects are immutable, so:

```csharp
public readonly record struct Containor<T> {...}
//or
public record Containor<T> {...}
```

The choice depends on the functionality required.  In general use a `struct` unless...

The basic `Containor` object:

```csharp
public readonly record struct Containor<T>
{
    private readonly T Value;

    public Containor(T value)
        => this.Value = value;
}
```

Which does absolutely nothing and hides it's internal value.

I'm a fan of the *Read/Write* paradigm, so I add the basic I/O to *Containor* like this:

```csharp
public static Containor<T> Read(T value)
    => new Containor<T>(value);

public T Write()
    => this.Value;
```

And then the first real *FP* code:

```csharp
public static Containor<T> Read(Func<T> func)
    => new Containor<T>(func.Invoke());

public void Write<TOut>(Action<T> action)
    => action.Invoke(this.Value);
```

This is real *FP* paradigm code: treating functions are *First Class Citizens*. Both methods are higher-order functions: they accept functions as arguments.

`Read` can receive any method matching the `Func<T>` pattern.  `Console.ReadLine()` is a good example.

This new I/O lets me write this simple console app:

```csharp
Containor<string?>
    .Read(Console.ReadLine)
    .Write<string?>(Console.WriteLine);
```

A simple factory for `Containor<T>` simplifies the constructors:

```csharp
public static class Containor
{
    public static Containor<T> Read<T>(T value)
        => Containor<T>.Read(value);

    public static Containor<T> Read<T>(Func<T> func)
        => Containor<T>.Read(func);
}
```

And the console app becomes:

```csharp
Containor
    .Read(Console.ReadLine)
    .Write<string?>(Console.WriteLine);
```

`Console.WriteLine(string)` matches the `Write` pattern.  `T` must be qualified for `Write` because the compiler doesn't know which version of `Console.WriteLine` to use.

## Pure Functions

Pure Functions always produce the same output for the same input without side effects.  They are self contained.  They also have  *referential transparency*.  Conider `Functor.Map(Math.Sqrt(4))`.  You can replace the method with `Functor.Map((input> => 2)` and you would bet the same result.

In C# pure functions can be written as `static` methods.

The big pluses with pure functions are:

 - they are easy to test and debug.
 - can be used in parallel code execution.

## Immutability

Variables, once defined, cannot be modified, ensuring consistent state management.

## Higher-Order Functions

Functions can be passed as arguments, returned from other functions, or stored in data structures.

## Iteraction

Iteration is achieved through recursive function calls instead of loops.

## Referential Transparency

Expressions can be replaced with their values without altering the program's behavior.