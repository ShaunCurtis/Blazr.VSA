# Commands



A command can be defined as:

```csharp
public async Task<Bool<TRecord>> ExecuteCommandAsync<TRecord>(CommandRequest<TRecord> request, CancellationToken cancellationToken = new())
```

Commands have one of three actions: 

1. Update - overwrite the record in the data store.
2. Delete - delete the record from the data store.
3. Add - Add the record to the data store.
 
Command functionality is defined in an `EditState` readonly struct.  using an `enum` is problematic when you cross domain boundaries and API interfaces.  Search "c# why you shouldn't use emums" for more information on the topic.

```csharp
public readonly record struct EditState
{
    public const int StateCleanIndex = 0;
    public const int StateNewIndex = 1;
    public const int StateDirtyIndex = 2;
    public const int StateDeletedIndex = -1;

    public int Index { get; private init; } = 0;
    public string Value { get; private init; } = "None";

    public EditState() { }

    private EditState(int index, string value)
    {
        Index = index;
        Value = value;
    }

    public EditState AsDirty => this.Index == StateCleanIndex ? EditState.Dirty : this; 

    public override string ToString()
    {
        return this.Value;
    }

    public static EditState Clean = new EditState(StateCleanIndex, "Clean");
    public static EditState New = new EditState(StateNewIndex, "New");
    public static EditState Dirty = new EditState(StateDirtyIndex, "Dirty");
    public static EditState Deleted = new EditState(StateDeletedIndex, "Deleted");

    public static EditState GetState(int index)
        => (index) switch
        {
            StateNewIndex => EditState.New,
            StateDirtyIndex => EditState.Dirty,
            StateDeletedIndex => EditState.Deleted,
            _ => EditState.Clean,
        };
}
```

## Customer Command Pipeline
.
The `CustomerUIConnector` defines the method called from the UI

```csharp
public Func<StateRecord<DmoCustomer>, Task<Bool<CustomerId>>> RecordCommandAsync
    => record => _mediator.DispatchAsync(new CustomerCommandRequest(record));
```

## The CQS Request

```csharp
public readonly record struct CustomerCommandRequest(
        StateRecord<DmoCustomer> Item)
    : IRequest<Bool<CustomerId>>
{
    public static CustomerCommandRequest Create(DmoCustomer item, EditState state)
        => new CustomerCommandRequest(new(item, state));

    public static CustomerCommandRequest Create(DmoCustomer item, EditState state, Guid transactionId)
        => new CustomerCommandRequest(new(item, state, transactionId));
}

## The Mediator Handler

The handler is where the work is done.  The handler is a `IRequestHandler` that takes in the request and returns a `Bool<CustomerId>`.  The handler is responsible for getting the data from the database and returning it in the requested format.  In this case, it uses the registered generic `ICommandBroker` to get the data.

```csharp
public sealed record CustomerCommandHandler : IRequestHandler<CustomerCommandRequest, Bool<CustomerId>>
{
    private readonly IMessageBus _messageBus;
    private readonly IDbContextFactory<InMemoryInvoiceTestDbContext> _factory;

    public CustomerCommandHandler(IDbContextFactory<InMemoryInvoiceTestDbContext> factory, IMessageBus messageBus)
    {
        _factory = factory;
        _messageBus = messageBus;
    }

    public async Task<Bool<CustomerId>> HandleAsync(CustomerCommandRequest request, CancellationToken cancellationToken)
    {
        using var dbContext = _factory.CreateDbContext();

        // Get the record result
        var result = await dbContext
            .ExecuteCommandAsync<DboCustomer>(new CommandRequest<DboCustomer>(
                    Item: DboCustomer.Map(request.Item.Record),
                    State: request.Item.State
                ),
                cancellationToken);

        //If the result is successful, we publish the DmoCustomer to the message bus
        // and return the Id - this may have been generated by the database
        return result.Bind<DboCustomer, CustomerId>(record =>
            {
                var id = new CustomerId(record.CustomerID);
                _messageBus.Publish<DmoCustomer>(id);
                return BoolT.Read(id);
            }
        );
    }
}
```

Note that the Handler publishes a message to the MessageBus against the `DmoCustomer` type with the affected Id to broadcast the change. 

### The CQS Broker

The handler calls `ExecuteCommandAsync` against the `DbContext`

```csharp
public static async Task<Bool<TRecord>> ExecuteCommandAsync<TRecord>(this DbContext dbContext, CommandRequest<TRecord> request, CancellationToken cancellationToken = new())
    where TRecord : class
        => await CQSEFBroker<DbContext>.ExecuteCommandAsync(dbContext, request, cancellationToken).ConfigureAwait(ConfigureAwaitOptions.None);
```

Which then executes the `CQSEFBroker` method `ExecuteCommandAsync`. 

Note: `TRecord` needs to implement `ICommandEntity`.  This is a marker interface that indicates the record can be updated, added or deleted.

```csharp
public static async Task<Bool<TRecord>> ExecuteCommandAsync<TRecord>(TDbContext dbContext, CommandRequest<TRecord> request, CancellationToken cancellationToken = new())
    where TRecord : class
{
    if ((request.Item is not ICommandEntity))
        return Bool<TRecord>.Failure($"{request.Item.GetType().Name} Does not implement ICommandEntity and therefore you can't Update/Add/Delete it directly.");

    var stateRecord = request.Item;
    var result = 0;
    switch (request.State.Index)
    {
        case EditState.StateNewIndex:
            dbContext.Add<TRecord>(request.Item);
            result = await dbContext.SaveChangesAsync(cancellationToken).ConfigureAwait(ConfigureAwaitOptions.None);

            return result == 1
                ? Bool<TRecord>.Success(request.Item)
                : Bool<TRecord>.Failure("Error adding Record");

        case EditState.StateDeletedIndex:
            dbContext.Remove<TRecord>(request.Item);
            result = await dbContext.SaveChangesAsync(cancellationToken).ConfigureAwait(ConfigureAwaitOptions.None);

            return result == 1
                ? Bool<TRecord>.Success(request.Item)
                : Bool<TRecord>.Failure("Error deleting Record");

        case EditState.StateDirtyIndex:
            dbContext.Update<TRecord>(request.Item);
            result = await dbContext.SaveChangesAsync(cancellationToken).ConfigureAwait(ConfigureAwaitOptions.None);

            return result == 1
                ? Bool<TRecord>.Success(request.Item)
                : Bool<TRecord>.Failure("Error saving Record");

        default:
            return Bool<TRecord>.Failure("Nothing executed.  Unrecognised State.");
    }
}
```

## The Result

`ExecuteCommandAsync` returns a `Bool<TRecord>`, the record that the handler updated.  *EF* will have replaced any database generated Ids in the record.

The Handler returns `Task<Bool<CustomerId>>`. 
